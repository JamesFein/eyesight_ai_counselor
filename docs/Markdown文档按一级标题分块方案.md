# Markdown 文档按一级标题分块方案

## 一、现有文档结构分析

### 1.1 文档概况

data 目录下共有 9 个眼科专业 Markdown 文档：

| 文档名称 | 大致行数 | 一级标题章节数 |
|----------|----------|----------------|
| 近视管理白皮书（2025） | ~155 行 | 5 个 |
| 近视管理白皮书（2022） | 待确认 | 待确认 |
| 近视管理白皮书（2019） | 待确认 | 待确认 |
| 近视防治指南（2024年版） | ~207 行 | 5 个 |
| 低浓度阿托品滴眼液专家共识（2024） | ~144 行 | 6 个 |
| 角膜塑形镜验配流程专家共识（2021） | 待确认 | 待确认 |
| 角膜塑形镜十问十答 | ~83 行 | 4 个 |
| 应用于近视控制的多焦软镜验配专家共识（2023） | ~74 行 | 6 个 |
| 近视防控相关框架眼镜专家共识（2023） | 待确认 | 待确认 |

### 1.2 统一的文档结构模式

所有文档均遵循相同的 Markdown 层级结构：

```
# 文档标题                    ← 一级标题（文档名称）

## 背景与摘要                 ← 二级标题（元数据区域）
正文内容...

## 文档信息                   ← 二级标题（元数据区域）
- 来源: xxx
- 作者: xxx
- 发布时间: xxx
- DOI: xxx
- 关键词: xxx

---                           ← 水平分隔线（元数据与正文的分界）

# 1 第一章标题                ← 一级标题（正文章节）
## 1.1 子章节
### 1.1.1 小节
正文内容...

# 2 第二章标题                ← 一级标题（正文章节）
...
```

### 1.3 结构特点总结

1. **一级标题的两种用途**：
   - 文档开头的一级标题表示文档名称
   - `---` 分隔线之后的一级标题表示正文章节

2. **层级清晰**：
   - 一级标题 `#`：章节级别
   - 二级标题 `##`：子章节级别
   - 三级标题 `###`：小节级别
   - 四级标题 `####`：细分内容（较少使用）

3. **内容特点**：
   - 专业术语密集
   - 包含列表、表格
   - 部分文档包含图片链接
   - 引用标注（如 [1]、[2-3]）

---

## 二、分块策略设计

### 2.1 核心思路

采用 **递归分块策略**，按照标题层级从高到低依次尝试分割：

**分割优先级**（从高到低）：
1. 一级标题 `# ` → 按章节分块
2. 二级标题 `## ` → 章节过长时，按子章节分块
3. 三级标题 `### ` → 子章节过长时，按小节分块
4. 段落 `\n\n` → 小节过长时，按段落分块
5. 句子（句号、问号、感叹号）→ 段落过长时，按句子分块
6. Token 级别 → 最后兜底

### 2.2 为什么选择递归分块

1. **保持语义完整性**：优先在标题边界切分，确保每个 chunk 是一个完整的知识单元
2. **自适应长度**：短章节保持完整，长章节自动细分
3. **层级信息保留**：分块时保留标题，便于理解上下文
4. **灵活应对不同文档**：无论文档长短，都能合理分块

### 2.3 分块参数设计

| 参数 | 推荐值 | 说明 |
|------|--------|------|
| chunk_size | 800-1024 tokens | 中文专业文档内容密集，不宜过大；同时要留出 embedding 模型的余量 |
| chunk_overlap | 0 | 按标题分块时，各章节相互独立，无需重叠 |
| min_characters_per_chunk | 100 | 避免产生过小的孤立块（如只有一个标题） |
| include_delim | "next" | 标题保留在下一个块的开头，而非上一个块的结尾 |

### 2.4 参数选择理由

**为什么 chunk_size 设为 800-1024？**
- 大多数 embedding 模型支持 512-8192 tokens
- 中文文本 1 个汉字约等于 1-2 tokens
- 800-1024 tokens 约等于 400-600 个汉字
- 这个长度既能包含完整的知识点，又不会过长影响检索精度

**为什么 overlap 设为 0？**
- 按标题分块后，每个 chunk 是独立的语义单元
- 重叠会导致重复信息，增加存储成本
- 如果需要上下文关联，可以在检索时返回相邻 chunk

---

## 三、处理新文档的意外情况

### 3.1 文档格式异常

| 异常情况 | 检测方法 | 处理策略 |
|----------|----------|----------|
| 无一级标题 | 检查是否存在 `\n# ` 模式 | 降级使用二级标题分割；若也无二级标题，则按段落分割 |
| 标题格式错误（如 `#无空格`） | 正则匹配 `^#{1,6}[^\s#]` | 预处理时自动在 `#` 后插入空格 |
| 混合使用不同标题风格 | 人工检查 | 统一转换为 ATX 风格（`#` 号风格） |

### 3.2 内容长度异常

| 异常情况 | 检测方法 | 处理策略 |
|----------|----------|----------|
| 文档内容过短（< 500 字符） | 检查文件长度 | 整体作为单个 chunk，记录警告日志 |
| 单个章节过长（> 2x chunk_size） | 分块后检查 token 数 | RecursiveChunker 自动按下级规则继续分割 |
| 空文件 | 检查文件是否为空 | 跳过该文件，记录错误日志 |

### 3.3 编码与格式问题

| 异常情况 | 检测方法 | 处理策略 |
|----------|----------|----------|
| 编码错误 | 尝试 UTF-8 解码失败 | 依次尝试 GBK、GB2312 等编码 |
| 换行符不统一 | 检查是否包含 `\r\n` 或 `\r` | 预处理时统一转换为 `\n` |
| 过多连续空行 | 正则匹配 `\n{3,}` | 预处理时压缩为最多 2 个连续换行 |

### 3.4 特殊内容处理

| 内容类型 | 处理策略 |
|----------|----------|
| 图片链接 `![alt](url)` | 保留原样，或替换为 `[图片: alt]` 占位符 |
| 表格 | 保持表格完整，不在表格中间切分 |
| 代码块 | 保持代码块完整，不在代码块中间切分 |
| 引用标注 `[1]` | 保留原样，作为文本一部分 |
| 列表项 | 尽量保持同一列表在同一 chunk |

---

## 四、预处理流程

在分块之前，对原始文档进行预处理，确保格式统一：

### 4.1 预处理步骤

1. **统一换行符**：将 `\r\n` 和 `\r` 统一转换为 `\n`
2. **压缩空行**：将 3 个及以上连续换行压缩为 2 个
3. **修复标题格式**：确保 `#` 后有空格
4. **去除行首行尾空白**：每行 trim 处理
5. **可选：处理图片链接**：根据需求保留或替换

### 4.2 预处理的必要性

- 不同编辑器产生的文档格式可能不同
- 复制粘贴可能引入异常字符
- 手工编辑可能造成格式不规范
- 预处理确保分块器能正确识别标题边界

---

## 五、分块结果的元数据

每个 chunk 应携带以下元数据，便于后续检索和溯源：

| 元数据字段 | 说明 | 示例 |
|------------|------|------|
| text | chunk 的文本内容 | "# 1 高质量近视管理临床研究..." |
| token_count | token 数量 | 856 |
| chunk_index | 在该文档中的序号 | 0, 1, 2, ... |
| source_file | 来源文件名 | "近视管理白皮书（2025）.md" |
| start_index | 在原文中的起始位置 | 1234 |
| end_index | 在原文中的结束位置 | 2567 |

---

## 六、质量验证建议

分块完成后，建议进行以下验证：

1. **检查 chunk 数量**：每个文档的 chunk 数量应在合理范围内（通常 5-20 个）
2. **检查 token 分布**：大多数 chunk 的 token 数应接近 chunk_size，避免过多极短或极长的 chunk
3. **抽样人工检查**：随机抽取若干 chunk，检查内容是否完整、边界是否合理
4. **检查标题保留**：确认每个 chunk 开头是否正确保留了标题

---

## 七、工具选择

推荐使用 **Chonkie** 库的 `RecursiveChunker`，理由如下：

1. **支持自定义分割规则**：可以按照 Markdown 标题层级设置分割优先级
2. **递归分块机制**：自动处理超长内容的细分
3. **支持多种 tokenizer**：可与 embedding 模型的 tokenizer 保持一致
4. **提供预设 recipe**：有现成的 markdown 分块配方可供参考
5. **轻量高效**：适合处理中等规模的文档集

---

## 八、后续扩展考虑

1. **增量更新**：新增文档时，只需对新文档进行分块，无需重新处理所有文档
2. **版本管理**：同一指南的不同年份版本（如 2019、2022、2025），可通过元数据区分
3. **跨文档去重**：不同文档可能有重复内容（如都引用同一研究结论），可考虑在向量化后进行相似度去重
4. **动态 chunk_size**：根据文档类型或章节特点，动态调整 chunk_size（如问答类文档可用较小的 chunk_size）
